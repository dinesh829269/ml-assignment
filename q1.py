# -*- coding: utf-8 -*-
"""Q1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q_lHnwAry7Mj8UhZMk4sX6FjzUCVxNg3
"""

#import libraries
import numpy as np
import matplotlib.pyplot as plt

#training Sample
data = np.array([[1,1], [-1, -1], [0, 0.5], [0.1, 0.5], [0.2, 0.2], [0.9, 0.5]])
label = np.array([1, -1, -1, -1, 1, 1])

#learning Rate
lr = 1
b = 0

#weight Vector
w = np.array([1,1])

#Checking the loop execution
count=0
converged=False
steps=0

#Perceptron Loop
while not converged:
    steps+=1
    count=0
    for i in range(len(data)):
        
        #check if y*f(x) >=1, The code then breaks
        if label[i]*(w.T.dot(data[i])+b) >=1:
            count+=1
            
        #Else weights are updated
        else:
            w=w+lr*label[i]*data[i]
            b=b+lr*label[i]
            
        if count==len(data):
            converged=True
    print("Vectors Weights in step ", steps, " is ", w)
            
#Printing Converge Total Steps
print("Converged in steps : ", steps)

#plotting the training data
plt.scatter(data[:, 0], data[:, 1], c=label)

#plotting decision boundary
x1 = np.linspace(-1, 1, 100)
x2 = -w[0]/w[1] * x1
plt.plot(x1, x2, 'k-')
plt.show()